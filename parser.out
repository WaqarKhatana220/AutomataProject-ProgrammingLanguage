Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    EQUALEQUAL
    GREATERTHAN
    GREATERTHANEQUALTO
    LESSTHAN
    LESSTHANEQUALTO
    MINUSMINUS
    NOT
    NOTEQUAL
    OR
    PLUSPLUS

Grammar

Rule 0     S' -> S
Rule 1     S -> stmt S
Rule 2     S -> <empty>
Rule 3     stmt -> PRINT LPAREN exp RPAREN SEMICOLON
Rule 4     exp -> exp PLUS exp
Rule 5     exp -> exp MINUS exp
Rule 6     exp -> exp DIVIDE exp
Rule 7     exp -> exp MULTIPLY exp
Rule 8     exp -> exp MODULUS exp
Rule 9     exp -> exp POWER exp
Rule 10    exp -> exp COMMA exp
Rule 11    exp -> INT
Rule 12    exp -> FLOAT
Rule 13    exp -> STRING
Rule 14    exp -> CHAR
Rule 15    exp -> BOOL
Rule 16    exp -> NAME
Rule 17    stmt -> DTYPE NAME EQUAL exp SEMICOLON
Rule 18    DTYPE -> int
Rule 19    DTYPE -> string
Rule 20    DTYPE -> float
Rule 21    DTYPE -> bool
Rule 22    DTYPE -> char
Rule 23    stmt -> NAME EQUAL exp SEMICOLON

Terminals, with rules where they appear

AND                  : 
BOOL                 : 15
CHAR                 : 14
COMMA                : 10
DIVIDE               : 6
EQUAL                : 17 23
EQUALEQUAL           : 
FLOAT                : 12
GREATERTHAN          : 
GREATERTHANEQUALTO   : 
INT                  : 11
LESSTHAN             : 
LESSTHANEQUALTO      : 
LPAREN               : 3
MINUS                : 5
MINUSMINUS           : 
MODULUS              : 8
MULTIPLY             : 7
NAME                 : 16 17 23
NOT                  : 
NOTEQUAL             : 
OR                   : 
PLUS                 : 4
PLUSPLUS             : 
POWER                : 9
PRINT                : 3
RPAREN               : 3
SEMICOLON            : 3 17 23
STRING               : 13
bool                 : 21
char                 : 22
error                : 
float                : 20
int                  : 18
string               : 19

Nonterminals, with rules where they appear

DTYPE                : 17
S                    : 1 0
exp                  : 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 17 23
stmt                 : 1

Parsing method: LALR

state 0

    (0) S' -> . S
    (1) S -> . stmt S
    (2) S -> .
    (3) stmt -> . PRINT LPAREN exp RPAREN SEMICOLON
    (17) stmt -> . DTYPE NAME EQUAL exp SEMICOLON
    (23) stmt -> . NAME EQUAL exp SEMICOLON
    (18) DTYPE -> . int
    (19) DTYPE -> . string
    (20) DTYPE -> . float
    (21) DTYPE -> . bool
    (22) DTYPE -> . char

    $end            reduce using rule 2 (S -> .)
    PRINT           shift and go to state 3
    NAME            shift and go to state 5
    int             shift and go to state 6
    string          shift and go to state 7
    float           shift and go to state 8
    bool            shift and go to state 9
    char            shift and go to state 10

    S                              shift and go to state 1
    stmt                           shift and go to state 2
    DTYPE                          shift and go to state 4

state 1

    (0) S' -> S .



state 2

    (1) S -> stmt . S
    (1) S -> . stmt S
    (2) S -> .
    (3) stmt -> . PRINT LPAREN exp RPAREN SEMICOLON
    (17) stmt -> . DTYPE NAME EQUAL exp SEMICOLON
    (23) stmt -> . NAME EQUAL exp SEMICOLON
    (18) DTYPE -> . int
    (19) DTYPE -> . string
    (20) DTYPE -> . float
    (21) DTYPE -> . bool
    (22) DTYPE -> . char

    $end            reduce using rule 2 (S -> .)
    PRINT           shift and go to state 3
    NAME            shift and go to state 5
    int             shift and go to state 6
    string          shift and go to state 7
    float           shift and go to state 8
    bool            shift and go to state 9
    char            shift and go to state 10

    stmt                           shift and go to state 2
    S                              shift and go to state 11
    DTYPE                          shift and go to state 4

state 3

    (3) stmt -> PRINT . LPAREN exp RPAREN SEMICOLON

    LPAREN          shift and go to state 12


state 4

    (17) stmt -> DTYPE . NAME EQUAL exp SEMICOLON

    NAME            shift and go to state 13


state 5

    (23) stmt -> NAME . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 14


state 6

    (18) DTYPE -> int .

    NAME            reduce using rule 18 (DTYPE -> int .)


state 7

    (19) DTYPE -> string .

    NAME            reduce using rule 19 (DTYPE -> string .)


state 8

    (20) DTYPE -> float .

    NAME            reduce using rule 20 (DTYPE -> float .)


state 9

    (21) DTYPE -> bool .

    NAME            reduce using rule 21 (DTYPE -> bool .)


state 10

    (22) DTYPE -> char .

    NAME            reduce using rule 22 (DTYPE -> char .)


state 11

    (1) S -> stmt S .

    $end            reduce using rule 1 (S -> stmt S .)


state 12

    (3) stmt -> PRINT LPAREN . exp RPAREN SEMICOLON
    (4) exp -> . exp PLUS exp
    (5) exp -> . exp MINUS exp
    (6) exp -> . exp DIVIDE exp
    (7) exp -> . exp MULTIPLY exp
    (8) exp -> . exp MODULUS exp
    (9) exp -> . exp POWER exp
    (10) exp -> . exp COMMA exp
    (11) exp -> . INT
    (12) exp -> . FLOAT
    (13) exp -> . STRING
    (14) exp -> . CHAR
    (15) exp -> . BOOL
    (16) exp -> . NAME

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    NAME            shift and go to state 21

    exp                            shift and go to state 15

state 13

    (17) stmt -> DTYPE NAME . EQUAL exp SEMICOLON

    EQUAL           shift and go to state 22


state 14

    (23) stmt -> NAME EQUAL . exp SEMICOLON
    (4) exp -> . exp PLUS exp
    (5) exp -> . exp MINUS exp
    (6) exp -> . exp DIVIDE exp
    (7) exp -> . exp MULTIPLY exp
    (8) exp -> . exp MODULUS exp
    (9) exp -> . exp POWER exp
    (10) exp -> . exp COMMA exp
    (11) exp -> . INT
    (12) exp -> . FLOAT
    (13) exp -> . STRING
    (14) exp -> . CHAR
    (15) exp -> . BOOL
    (16) exp -> . NAME

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    NAME            shift and go to state 21

    exp                            shift and go to state 23

state 15

    (3) stmt -> PRINT LPAREN exp . RPAREN SEMICOLON
    (4) exp -> exp . PLUS exp
    (5) exp -> exp . MINUS exp
    (6) exp -> exp . DIVIDE exp
    (7) exp -> exp . MULTIPLY exp
    (8) exp -> exp . MODULUS exp
    (9) exp -> exp . POWER exp
    (10) exp -> exp . COMMA exp

    RPAREN          shift and go to state 24
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    DIVIDE          shift and go to state 27
    MULTIPLY        shift and go to state 28
    MODULUS         shift and go to state 29
    POWER           shift and go to state 30
    COMMA           shift and go to state 31


state 16

    (11) exp -> INT .

    RPAREN          reduce using rule 11 (exp -> INT .)
    PLUS            reduce using rule 11 (exp -> INT .)
    MINUS           reduce using rule 11 (exp -> INT .)
    DIVIDE          reduce using rule 11 (exp -> INT .)
    MULTIPLY        reduce using rule 11 (exp -> INT .)
    MODULUS         reduce using rule 11 (exp -> INT .)
    POWER           reduce using rule 11 (exp -> INT .)
    COMMA           reduce using rule 11 (exp -> INT .)
    SEMICOLON       reduce using rule 11 (exp -> INT .)


state 17

    (12) exp -> FLOAT .

    RPAREN          reduce using rule 12 (exp -> FLOAT .)
    PLUS            reduce using rule 12 (exp -> FLOAT .)
    MINUS           reduce using rule 12 (exp -> FLOAT .)
    DIVIDE          reduce using rule 12 (exp -> FLOAT .)
    MULTIPLY        reduce using rule 12 (exp -> FLOAT .)
    MODULUS         reduce using rule 12 (exp -> FLOAT .)
    POWER           reduce using rule 12 (exp -> FLOAT .)
    COMMA           reduce using rule 12 (exp -> FLOAT .)
    SEMICOLON       reduce using rule 12 (exp -> FLOAT .)


state 18

    (13) exp -> STRING .

    RPAREN          reduce using rule 13 (exp -> STRING .)
    PLUS            reduce using rule 13 (exp -> STRING .)
    MINUS           reduce using rule 13 (exp -> STRING .)
    DIVIDE          reduce using rule 13 (exp -> STRING .)
    MULTIPLY        reduce using rule 13 (exp -> STRING .)
    MODULUS         reduce using rule 13 (exp -> STRING .)
    POWER           reduce using rule 13 (exp -> STRING .)
    COMMA           reduce using rule 13 (exp -> STRING .)
    SEMICOLON       reduce using rule 13 (exp -> STRING .)


state 19

    (14) exp -> CHAR .

    RPAREN          reduce using rule 14 (exp -> CHAR .)
    PLUS            reduce using rule 14 (exp -> CHAR .)
    MINUS           reduce using rule 14 (exp -> CHAR .)
    DIVIDE          reduce using rule 14 (exp -> CHAR .)
    MULTIPLY        reduce using rule 14 (exp -> CHAR .)
    MODULUS         reduce using rule 14 (exp -> CHAR .)
    POWER           reduce using rule 14 (exp -> CHAR .)
    COMMA           reduce using rule 14 (exp -> CHAR .)
    SEMICOLON       reduce using rule 14 (exp -> CHAR .)


state 20

    (15) exp -> BOOL .

    RPAREN          reduce using rule 15 (exp -> BOOL .)
    PLUS            reduce using rule 15 (exp -> BOOL .)
    MINUS           reduce using rule 15 (exp -> BOOL .)
    DIVIDE          reduce using rule 15 (exp -> BOOL .)
    MULTIPLY        reduce using rule 15 (exp -> BOOL .)
    MODULUS         reduce using rule 15 (exp -> BOOL .)
    POWER           reduce using rule 15 (exp -> BOOL .)
    COMMA           reduce using rule 15 (exp -> BOOL .)
    SEMICOLON       reduce using rule 15 (exp -> BOOL .)


state 21

    (16) exp -> NAME .

    RPAREN          reduce using rule 16 (exp -> NAME .)
    PLUS            reduce using rule 16 (exp -> NAME .)
    MINUS           reduce using rule 16 (exp -> NAME .)
    DIVIDE          reduce using rule 16 (exp -> NAME .)
    MULTIPLY        reduce using rule 16 (exp -> NAME .)
    MODULUS         reduce using rule 16 (exp -> NAME .)
    POWER           reduce using rule 16 (exp -> NAME .)
    COMMA           reduce using rule 16 (exp -> NAME .)
    SEMICOLON       reduce using rule 16 (exp -> NAME .)


state 22

    (17) stmt -> DTYPE NAME EQUAL . exp SEMICOLON
    (4) exp -> . exp PLUS exp
    (5) exp -> . exp MINUS exp
    (6) exp -> . exp DIVIDE exp
    (7) exp -> . exp MULTIPLY exp
    (8) exp -> . exp MODULUS exp
    (9) exp -> . exp POWER exp
    (10) exp -> . exp COMMA exp
    (11) exp -> . INT
    (12) exp -> . FLOAT
    (13) exp -> . STRING
    (14) exp -> . CHAR
    (15) exp -> . BOOL
    (16) exp -> . NAME

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    NAME            shift and go to state 21

    exp                            shift and go to state 32

state 23

    (23) stmt -> NAME EQUAL exp . SEMICOLON
    (4) exp -> exp . PLUS exp
    (5) exp -> exp . MINUS exp
    (6) exp -> exp . DIVIDE exp
    (7) exp -> exp . MULTIPLY exp
    (8) exp -> exp . MODULUS exp
    (9) exp -> exp . POWER exp
    (10) exp -> exp . COMMA exp

    SEMICOLON       shift and go to state 33
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    DIVIDE          shift and go to state 27
    MULTIPLY        shift and go to state 28
    MODULUS         shift and go to state 29
    POWER           shift and go to state 30
    COMMA           shift and go to state 31


state 24

    (3) stmt -> PRINT LPAREN exp RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 34


state 25

    (4) exp -> exp PLUS . exp
    (4) exp -> . exp PLUS exp
    (5) exp -> . exp MINUS exp
    (6) exp -> . exp DIVIDE exp
    (7) exp -> . exp MULTIPLY exp
    (8) exp -> . exp MODULUS exp
    (9) exp -> . exp POWER exp
    (10) exp -> . exp COMMA exp
    (11) exp -> . INT
    (12) exp -> . FLOAT
    (13) exp -> . STRING
    (14) exp -> . CHAR
    (15) exp -> . BOOL
    (16) exp -> . NAME

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    NAME            shift and go to state 21

    exp                            shift and go to state 35

state 26

    (5) exp -> exp MINUS . exp
    (4) exp -> . exp PLUS exp
    (5) exp -> . exp MINUS exp
    (6) exp -> . exp DIVIDE exp
    (7) exp -> . exp MULTIPLY exp
    (8) exp -> . exp MODULUS exp
    (9) exp -> . exp POWER exp
    (10) exp -> . exp COMMA exp
    (11) exp -> . INT
    (12) exp -> . FLOAT
    (13) exp -> . STRING
    (14) exp -> . CHAR
    (15) exp -> . BOOL
    (16) exp -> . NAME

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    NAME            shift and go to state 21

    exp                            shift and go to state 36

state 27

    (6) exp -> exp DIVIDE . exp
    (4) exp -> . exp PLUS exp
    (5) exp -> . exp MINUS exp
    (6) exp -> . exp DIVIDE exp
    (7) exp -> . exp MULTIPLY exp
    (8) exp -> . exp MODULUS exp
    (9) exp -> . exp POWER exp
    (10) exp -> . exp COMMA exp
    (11) exp -> . INT
    (12) exp -> . FLOAT
    (13) exp -> . STRING
    (14) exp -> . CHAR
    (15) exp -> . BOOL
    (16) exp -> . NAME

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    NAME            shift and go to state 21

    exp                            shift and go to state 37

state 28

    (7) exp -> exp MULTIPLY . exp
    (4) exp -> . exp PLUS exp
    (5) exp -> . exp MINUS exp
    (6) exp -> . exp DIVIDE exp
    (7) exp -> . exp MULTIPLY exp
    (8) exp -> . exp MODULUS exp
    (9) exp -> . exp POWER exp
    (10) exp -> . exp COMMA exp
    (11) exp -> . INT
    (12) exp -> . FLOAT
    (13) exp -> . STRING
    (14) exp -> . CHAR
    (15) exp -> . BOOL
    (16) exp -> . NAME

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    NAME            shift and go to state 21

    exp                            shift and go to state 38

state 29

    (8) exp -> exp MODULUS . exp
    (4) exp -> . exp PLUS exp
    (5) exp -> . exp MINUS exp
    (6) exp -> . exp DIVIDE exp
    (7) exp -> . exp MULTIPLY exp
    (8) exp -> . exp MODULUS exp
    (9) exp -> . exp POWER exp
    (10) exp -> . exp COMMA exp
    (11) exp -> . INT
    (12) exp -> . FLOAT
    (13) exp -> . STRING
    (14) exp -> . CHAR
    (15) exp -> . BOOL
    (16) exp -> . NAME

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    NAME            shift and go to state 21

    exp                            shift and go to state 39

state 30

    (9) exp -> exp POWER . exp
    (4) exp -> . exp PLUS exp
    (5) exp -> . exp MINUS exp
    (6) exp -> . exp DIVIDE exp
    (7) exp -> . exp MULTIPLY exp
    (8) exp -> . exp MODULUS exp
    (9) exp -> . exp POWER exp
    (10) exp -> . exp COMMA exp
    (11) exp -> . INT
    (12) exp -> . FLOAT
    (13) exp -> . STRING
    (14) exp -> . CHAR
    (15) exp -> . BOOL
    (16) exp -> . NAME

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    NAME            shift and go to state 21

    exp                            shift and go to state 40

state 31

    (10) exp -> exp COMMA . exp
    (4) exp -> . exp PLUS exp
    (5) exp -> . exp MINUS exp
    (6) exp -> . exp DIVIDE exp
    (7) exp -> . exp MULTIPLY exp
    (8) exp -> . exp MODULUS exp
    (9) exp -> . exp POWER exp
    (10) exp -> . exp COMMA exp
    (11) exp -> . INT
    (12) exp -> . FLOAT
    (13) exp -> . STRING
    (14) exp -> . CHAR
    (15) exp -> . BOOL
    (16) exp -> . NAME

    INT             shift and go to state 16
    FLOAT           shift and go to state 17
    STRING          shift and go to state 18
    CHAR            shift and go to state 19
    BOOL            shift and go to state 20
    NAME            shift and go to state 21

    exp                            shift and go to state 41

state 32

    (17) stmt -> DTYPE NAME EQUAL exp . SEMICOLON
    (4) exp -> exp . PLUS exp
    (5) exp -> exp . MINUS exp
    (6) exp -> exp . DIVIDE exp
    (7) exp -> exp . MULTIPLY exp
    (8) exp -> exp . MODULUS exp
    (9) exp -> exp . POWER exp
    (10) exp -> exp . COMMA exp

    SEMICOLON       shift and go to state 42
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    DIVIDE          shift and go to state 27
    MULTIPLY        shift and go to state 28
    MODULUS         shift and go to state 29
    POWER           shift and go to state 30
    COMMA           shift and go to state 31


state 33

    (23) stmt -> NAME EQUAL exp SEMICOLON .

    PRINT           reduce using rule 23 (stmt -> NAME EQUAL exp SEMICOLON .)
    NAME            reduce using rule 23 (stmt -> NAME EQUAL exp SEMICOLON .)
    int             reduce using rule 23 (stmt -> NAME EQUAL exp SEMICOLON .)
    string          reduce using rule 23 (stmt -> NAME EQUAL exp SEMICOLON .)
    float           reduce using rule 23 (stmt -> NAME EQUAL exp SEMICOLON .)
    bool            reduce using rule 23 (stmt -> NAME EQUAL exp SEMICOLON .)
    char            reduce using rule 23 (stmt -> NAME EQUAL exp SEMICOLON .)
    $end            reduce using rule 23 (stmt -> NAME EQUAL exp SEMICOLON .)


state 34

    (3) stmt -> PRINT LPAREN exp RPAREN SEMICOLON .

    PRINT           reduce using rule 3 (stmt -> PRINT LPAREN exp RPAREN SEMICOLON .)
    NAME            reduce using rule 3 (stmt -> PRINT LPAREN exp RPAREN SEMICOLON .)
    int             reduce using rule 3 (stmt -> PRINT LPAREN exp RPAREN SEMICOLON .)
    string          reduce using rule 3 (stmt -> PRINT LPAREN exp RPAREN SEMICOLON .)
    float           reduce using rule 3 (stmt -> PRINT LPAREN exp RPAREN SEMICOLON .)
    bool            reduce using rule 3 (stmt -> PRINT LPAREN exp RPAREN SEMICOLON .)
    char            reduce using rule 3 (stmt -> PRINT LPAREN exp RPAREN SEMICOLON .)
    $end            reduce using rule 3 (stmt -> PRINT LPAREN exp RPAREN SEMICOLON .)


state 35

    (4) exp -> exp PLUS exp .
    (4) exp -> exp . PLUS exp
    (5) exp -> exp . MINUS exp
    (6) exp -> exp . DIVIDE exp
    (7) exp -> exp . MULTIPLY exp
    (8) exp -> exp . MODULUS exp
    (9) exp -> exp . POWER exp
    (10) exp -> exp . COMMA exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 4 (exp -> exp PLUS exp .)
    SEMICOLON       reduce using rule 4 (exp -> exp PLUS exp .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    DIVIDE          shift and go to state 27
    MULTIPLY        shift and go to state 28
    MODULUS         shift and go to state 29
    POWER           shift and go to state 30
    COMMA           shift and go to state 31

  ! PLUS            [ reduce using rule 4 (exp -> exp PLUS exp .) ]
  ! MINUS           [ reduce using rule 4 (exp -> exp PLUS exp .) ]
  ! DIVIDE          [ reduce using rule 4 (exp -> exp PLUS exp .) ]
  ! MULTIPLY        [ reduce using rule 4 (exp -> exp PLUS exp .) ]
  ! MODULUS         [ reduce using rule 4 (exp -> exp PLUS exp .) ]
  ! POWER           [ reduce using rule 4 (exp -> exp PLUS exp .) ]
  ! COMMA           [ reduce using rule 4 (exp -> exp PLUS exp .) ]


state 36

    (5) exp -> exp MINUS exp .
    (4) exp -> exp . PLUS exp
    (5) exp -> exp . MINUS exp
    (6) exp -> exp . DIVIDE exp
    (7) exp -> exp . MULTIPLY exp
    (8) exp -> exp . MODULUS exp
    (9) exp -> exp . POWER exp
    (10) exp -> exp . COMMA exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 5 (exp -> exp MINUS exp .)
    SEMICOLON       reduce using rule 5 (exp -> exp MINUS exp .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    DIVIDE          shift and go to state 27
    MULTIPLY        shift and go to state 28
    MODULUS         shift and go to state 29
    POWER           shift and go to state 30
    COMMA           shift and go to state 31

  ! PLUS            [ reduce using rule 5 (exp -> exp MINUS exp .) ]
  ! MINUS           [ reduce using rule 5 (exp -> exp MINUS exp .) ]
  ! DIVIDE          [ reduce using rule 5 (exp -> exp MINUS exp .) ]
  ! MULTIPLY        [ reduce using rule 5 (exp -> exp MINUS exp .) ]
  ! MODULUS         [ reduce using rule 5 (exp -> exp MINUS exp .) ]
  ! POWER           [ reduce using rule 5 (exp -> exp MINUS exp .) ]
  ! COMMA           [ reduce using rule 5 (exp -> exp MINUS exp .) ]


state 37

    (6) exp -> exp DIVIDE exp .
    (4) exp -> exp . PLUS exp
    (5) exp -> exp . MINUS exp
    (6) exp -> exp . DIVIDE exp
    (7) exp -> exp . MULTIPLY exp
    (8) exp -> exp . MODULUS exp
    (9) exp -> exp . POWER exp
    (10) exp -> exp . COMMA exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 6 (exp -> exp DIVIDE exp .)
    SEMICOLON       reduce using rule 6 (exp -> exp DIVIDE exp .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    DIVIDE          shift and go to state 27
    MULTIPLY        shift and go to state 28
    MODULUS         shift and go to state 29
    POWER           shift and go to state 30
    COMMA           shift and go to state 31

  ! PLUS            [ reduce using rule 6 (exp -> exp DIVIDE exp .) ]
  ! MINUS           [ reduce using rule 6 (exp -> exp DIVIDE exp .) ]
  ! DIVIDE          [ reduce using rule 6 (exp -> exp DIVIDE exp .) ]
  ! MULTIPLY        [ reduce using rule 6 (exp -> exp DIVIDE exp .) ]
  ! MODULUS         [ reduce using rule 6 (exp -> exp DIVIDE exp .) ]
  ! POWER           [ reduce using rule 6 (exp -> exp DIVIDE exp .) ]
  ! COMMA           [ reduce using rule 6 (exp -> exp DIVIDE exp .) ]


state 38

    (7) exp -> exp MULTIPLY exp .
    (4) exp -> exp . PLUS exp
    (5) exp -> exp . MINUS exp
    (6) exp -> exp . DIVIDE exp
    (7) exp -> exp . MULTIPLY exp
    (8) exp -> exp . MODULUS exp
    (9) exp -> exp . POWER exp
    (10) exp -> exp . COMMA exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 7 (exp -> exp MULTIPLY exp .)
    SEMICOLON       reduce using rule 7 (exp -> exp MULTIPLY exp .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    DIVIDE          shift and go to state 27
    MULTIPLY        shift and go to state 28
    MODULUS         shift and go to state 29
    POWER           shift and go to state 30
    COMMA           shift and go to state 31

  ! PLUS            [ reduce using rule 7 (exp -> exp MULTIPLY exp .) ]
  ! MINUS           [ reduce using rule 7 (exp -> exp MULTIPLY exp .) ]
  ! DIVIDE          [ reduce using rule 7 (exp -> exp MULTIPLY exp .) ]
  ! MULTIPLY        [ reduce using rule 7 (exp -> exp MULTIPLY exp .) ]
  ! MODULUS         [ reduce using rule 7 (exp -> exp MULTIPLY exp .) ]
  ! POWER           [ reduce using rule 7 (exp -> exp MULTIPLY exp .) ]
  ! COMMA           [ reduce using rule 7 (exp -> exp MULTIPLY exp .) ]


state 39

    (8) exp -> exp MODULUS exp .
    (4) exp -> exp . PLUS exp
    (5) exp -> exp . MINUS exp
    (6) exp -> exp . DIVIDE exp
    (7) exp -> exp . MULTIPLY exp
    (8) exp -> exp . MODULUS exp
    (9) exp -> exp . POWER exp
    (10) exp -> exp . COMMA exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 8 (exp -> exp MODULUS exp .)
    SEMICOLON       reduce using rule 8 (exp -> exp MODULUS exp .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    DIVIDE          shift and go to state 27
    MULTIPLY        shift and go to state 28
    MODULUS         shift and go to state 29
    POWER           shift and go to state 30
    COMMA           shift and go to state 31

  ! PLUS            [ reduce using rule 8 (exp -> exp MODULUS exp .) ]
  ! MINUS           [ reduce using rule 8 (exp -> exp MODULUS exp .) ]
  ! DIVIDE          [ reduce using rule 8 (exp -> exp MODULUS exp .) ]
  ! MULTIPLY        [ reduce using rule 8 (exp -> exp MODULUS exp .) ]
  ! MODULUS         [ reduce using rule 8 (exp -> exp MODULUS exp .) ]
  ! POWER           [ reduce using rule 8 (exp -> exp MODULUS exp .) ]
  ! COMMA           [ reduce using rule 8 (exp -> exp MODULUS exp .) ]


state 40

    (9) exp -> exp POWER exp .
    (4) exp -> exp . PLUS exp
    (5) exp -> exp . MINUS exp
    (6) exp -> exp . DIVIDE exp
    (7) exp -> exp . MULTIPLY exp
    (8) exp -> exp . MODULUS exp
    (9) exp -> exp . POWER exp
    (10) exp -> exp . COMMA exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 9 (exp -> exp POWER exp .)
    SEMICOLON       reduce using rule 9 (exp -> exp POWER exp .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    DIVIDE          shift and go to state 27
    MULTIPLY        shift and go to state 28
    MODULUS         shift and go to state 29
    POWER           shift and go to state 30
    COMMA           shift and go to state 31

  ! PLUS            [ reduce using rule 9 (exp -> exp POWER exp .) ]
  ! MINUS           [ reduce using rule 9 (exp -> exp POWER exp .) ]
  ! DIVIDE          [ reduce using rule 9 (exp -> exp POWER exp .) ]
  ! MULTIPLY        [ reduce using rule 9 (exp -> exp POWER exp .) ]
  ! MODULUS         [ reduce using rule 9 (exp -> exp POWER exp .) ]
  ! POWER           [ reduce using rule 9 (exp -> exp POWER exp .) ]
  ! COMMA           [ reduce using rule 9 (exp -> exp POWER exp .) ]


state 41

    (10) exp -> exp COMMA exp .
    (4) exp -> exp . PLUS exp
    (5) exp -> exp . MINUS exp
    (6) exp -> exp . DIVIDE exp
    (7) exp -> exp . MULTIPLY exp
    (8) exp -> exp . MODULUS exp
    (9) exp -> exp . POWER exp
    (10) exp -> exp . COMMA exp

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MULTIPLY resolved as shift
  ! shift/reduce conflict for MODULUS resolved as shift
  ! shift/reduce conflict for POWER resolved as shift
  ! shift/reduce conflict for COMMA resolved as shift
    RPAREN          reduce using rule 10 (exp -> exp COMMA exp .)
    SEMICOLON       reduce using rule 10 (exp -> exp COMMA exp .)
    PLUS            shift and go to state 25
    MINUS           shift and go to state 26
    DIVIDE          shift and go to state 27
    MULTIPLY        shift and go to state 28
    MODULUS         shift and go to state 29
    POWER           shift and go to state 30
    COMMA           shift and go to state 31

  ! PLUS            [ reduce using rule 10 (exp -> exp COMMA exp .) ]
  ! MINUS           [ reduce using rule 10 (exp -> exp COMMA exp .) ]
  ! DIVIDE          [ reduce using rule 10 (exp -> exp COMMA exp .) ]
  ! MULTIPLY        [ reduce using rule 10 (exp -> exp COMMA exp .) ]
  ! MODULUS         [ reduce using rule 10 (exp -> exp COMMA exp .) ]
  ! POWER           [ reduce using rule 10 (exp -> exp COMMA exp .) ]
  ! COMMA           [ reduce using rule 10 (exp -> exp COMMA exp .) ]


state 42

    (17) stmt -> DTYPE NAME EQUAL exp SEMICOLON .

    PRINT           reduce using rule 17 (stmt -> DTYPE NAME EQUAL exp SEMICOLON .)
    NAME            reduce using rule 17 (stmt -> DTYPE NAME EQUAL exp SEMICOLON .)
    int             reduce using rule 17 (stmt -> DTYPE NAME EQUAL exp SEMICOLON .)
    string          reduce using rule 17 (stmt -> DTYPE NAME EQUAL exp SEMICOLON .)
    float           reduce using rule 17 (stmt -> DTYPE NAME EQUAL exp SEMICOLON .)
    bool            reduce using rule 17 (stmt -> DTYPE NAME EQUAL exp SEMICOLON .)
    char            reduce using rule 17 (stmt -> DTYPE NAME EQUAL exp SEMICOLON .)
    $end            reduce using rule 17 (stmt -> DTYPE NAME EQUAL exp SEMICOLON .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 35 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 35 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 35 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 35 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 35 resolved as shift
WARNING: shift/reduce conflict for POWER in state 35 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 35 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 36 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 36 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 36 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 36 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 36 resolved as shift
WARNING: shift/reduce conflict for POWER in state 36 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 36 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 37 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 37 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 37 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 37 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 37 resolved as shift
WARNING: shift/reduce conflict for POWER in state 37 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 37 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 38 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 38 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 38 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 38 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 38 resolved as shift
WARNING: shift/reduce conflict for POWER in state 38 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 38 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 39 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 39 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 39 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 39 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 39 resolved as shift
WARNING: shift/reduce conflict for POWER in state 39 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 39 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 40 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 40 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 40 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 40 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 40 resolved as shift
WARNING: shift/reduce conflict for POWER in state 40 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 40 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 41 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 41 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 41 resolved as shift
WARNING: shift/reduce conflict for MULTIPLY in state 41 resolved as shift
WARNING: shift/reduce conflict for MODULUS in state 41 resolved as shift
WARNING: shift/reduce conflict for POWER in state 41 resolved as shift
WARNING: shift/reduce conflict for COMMA in state 41 resolved as shift
